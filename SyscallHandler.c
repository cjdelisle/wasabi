#include <sys/syscall.h>
#include <stdint.h>
#include <errno.h>
#include <assert.h>
#include <unistd.h>

#include <stdio.h>

#include "SyscallHandler.h"
#include "WasmABI.h"
#include "./build/syscall_autogenerated.h"

static unsigned long offset_g = 0;
static unsigned long top_g = 0;
static unsigned long scratch_space_l[1024];
static unsigned char* scratch_space = (unsigned char*) &scratch_space_l;

#define SYSCALL_SPECIAL(name) static inline unsigned long special_ ## name (\
    unsigned long arg0, unsigned long arg1, unsigned long arg2, \
    unsigned long arg3, unsigned long arg4, unsigned long arg5)

struct _iovec {
    unsigned long iov_base;    /* Starting address */
    unsigned long iov_len;     /* Number of bytes to transfer */
};

struct iovec32 {
    uint32_t iov_base;    /* Starting address */
    uint32_t iov_len;     /* Number of bytes to transfer */
};

SYSCALL_SPECIAL(SYS_writev) {
    for (unsigned int i = 0; i < arg2; i++) {
        struct _iovec* iov = &((struct _iovec*)scratch_space)[i];
        assert(((unsigned long)&iov[1]) < (unsigned long)(scratch_space + sizeof(scratch_space_l)));
        struct iovec32* iov32 = &((struct iovec32*) arg1)[i];
        iov->iov_base = offset_g + iov32->iov_base;
        iov->iov_len = iov32->iov_len;
    }
    arg1 = (unsigned long) scratch_space;
    return syscall(SYS_writev, arg0, arg1, arg2, arg3, arg4, arg5);
}

uint32_t SyscallHandler_doSyscall(
    uint32_t nr,
    unsigned long arg0,
    unsigned long arg1,
    unsigned long arg2,
    unsigned long arg3,
    unsigned long arg4,
    unsigned long arg5
) {
    if (nr > (sizeof(SYSCALL_NR_TBL) / sizeof(*SYSCALL_NR_TBL))) {
        printf("Syscall %u out of range\n", nr);
        return -ENOSYS;
    }
    if (!SYSCALL_NR_TBL[nr]) {
        printf("Syscall %u doesn't exist\n", nr);
        return -ENOSYS;
    }
    nr = SYSCALL_NR_TBL[nr] - 1;
    printf("Syscall %u %s(%lx, %lx, %lx, %lx, %lx, %lx)\n",
        nr, SYSCALL_NAMES[nr], arg0, arg1, arg2, arg3, arg4, arg5);
    if (!(SYSCALL_TRANSLATE[nr] >> 7)) {
        printf("unimplemented syscall\n");
        return -ENOSYS;
    }

    unsigned long ret;
    #define SPECIAL_CASE(name) case name: ret = special_ ## name (arg0, arg1, arg2, arg3, arg4, arg5); break
    #define TRANSLATE(_a) arg ## _a += (offset_g & (((SYSCALL_TRANSLATE[nr] >> (_a+1)) & 1) - 1));

    switch (nr) {
        case SYS_brk: return WasmABI_callFunc(Function_SYS_brk, arg0, 0, 0, 0, 0, 0);
        default: {
            TRANSLATE(0); TRANSLATE(1); TRANSLATE(2); TRANSLATE(3); TRANSLATE(4); TRANSLATE(5);
            switch (nr) {
                SPECIAL_CASE(SYS_writev);
                default: ret = syscall(nr, arg0, arg1, arg2, arg3, arg4, arg5);
            }
        }
    }
    //printf("%u = syscall(%ld, %lx, %lu)\n", (int) ret, arg0, arg1, arg2);
    if (!(SYSCALL_TRANSLATE[nr] & 1) && ret != (unsigned)-1) {
        // TODO we can get rid of this branch...
        ret -= (offset_g & ((SYSCALL_TRANSLATE[nr] & 1) - 1));
    }
    return (uint32_t) ret;
}

uint32_t SyscallHandler_doMemSyscall(uint32_t nr, uint32_t _addr)
{
    unsigned long realAddr = offset_g + _addr;
    if (realAddr > top_g) { return -EFAULT; }
    uint32_t* ptr = (uint32_t*) realAddr;
    return SyscallHandler_doSyscall(nr, ptr[0], ptr[1], ptr[2], ptr[3], ptr[4], ptr[5]);
}

void SyscallHandler_setAddressSpace(size_t memoryLocation, size_t length)
{
    offset_g = memoryLocation;
    top_g = offset_g + length;
}